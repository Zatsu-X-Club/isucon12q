.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "PT-TABLE-CHECKSUM 1p"
.TH PT-TABLE-CHECKSUM 1p "2016-03-07" "perl v5.34.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
pt\-table\-checksum \- Verify MySQL replication integrity.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Usage: pt-table-checksum [\s-1OPTIONS\s0] [\s-1DSN\s0]
.PP
pt-table-checksum performs an online replication consistency check by executing
checksum queries on the master, which produces different results on replicas
that are inconsistent with the master.  The optional \s-1DSN\s0 specifies the master
host.  The tool's \*(L"\s-1EXIT STATUS\*(R"\s0 is non-zero if any differences are found,
or if any warnings or errors occur.
.PP
The following command will connect to the replication master on localhost,
checksum every table, and report the results on every detected replica:
.PP
.Vb 1
\&   pt\-table\-checksum
.Ve
.PP
This tool is focused on finding data differences efficiently.  If any data is
different, you can resolve the problem with pt-table-sync.
.SH "RISKS"
.IX Header "RISKS"
Percona Toolkit is mature, proven in the real world, and well tested,
but all database tools can pose a risk to the system and the database
server.  Before using this tool, please:
.IP "\(bu" 4
Read the tool's documentation
.IP "\(bu" 4
Review the tool's known \*(L"\s-1BUGS\*(R"\s0
.IP "\(bu" 4
Test the tool on a non-production server
.IP "\(bu" 4
Backup your production server and verify the backups
.PP
See also \*(L"\s-1LIMITATIONS\*(R"\s0.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
pt-table-checksum is designed to do the right thing by default in almost every
case.  When in doubt, use \*(L"\-\-explain\*(R" to see how the tool will checksum a
table.  The following is a high-level overview of how the tool functions.
.PP
In contrast to older versions of pt-table-checksum, this tool is focused on a
single purpose, and does not have a lot of complexity or support many different
checksumming techniques.  It executes checksum queries on only one server, and
these flow through replication to re-execute on replicas.  If you need the older
behavior, you can use Percona Toolkit version 1.0.
.PP
pt-table-checksum connects to the server you specify, and finds databases and
tables that match the filters you specify (if any).  It works one table at a
time, so it does not accumulate large amounts of memory or do a lot of work
before beginning to checksum.  This makes it usable on very large servers. We
have used it on servers with hundreds of thousands of databases and tables, and
trillions of rows.  No matter how large the server is, pt-table-checksum works
equally well.
.PP
One reason it can work on very large tables is that it divides each table into
chunks of rows, and checksums each chunk with a single \s-1REPLACE..SELECT\s0 query.
It varies the chunk size to make the checksum queries run in the desired amount
of time.  The goal of chunking the tables, instead of doing each table with a
single big query, is to ensure that checksums are unintrusive and don't cause
too much replication lag or load on the server.  That's why the target time for
each chunk is 0.5 seconds by default.
.PP
The tool keeps track of how quickly the server is able to execute the queries,
and adjusts the chunks as it learns more about the server's performance.  It
uses an exponentially decaying weighted average to keep the chunk size stable,
yet remain responsive if the server's performance changes during checksumming
for any reason.  This means that the tool will quickly throttle itself if your
server becomes heavily loaded during a traffic spike or a background task, for
example.
.PP
Chunking is accomplished by a technique that we used to call \*(L"nibbling\*(R" in other
tools in Percona Toolkit.  It is the same technique used for pt-archiver, for
example.  The legacy chunking algorithms used in older versions of
pt-table-checksum are removed, because they did not result in predictably sized
chunks, and didn't work well on many tables.  All that is required to divide a
table into chunks is an index of some sort (preferably a primary key or unique
index).  If there is no index, and the table contains a suitably small number of
rows, the tool will checksum the table in a single chunk.
.PP
pt-table-checksum has many other safeguards to ensure that it does not interfere
with any server's operation, including replicas.  To accomplish this,
pt-table-checksum detects replicas and connects to them automatically.  (If this
fails, you can give it a hint with the \*(L"\-\-recursion\-method\*(R" option.)
.PP
The tool monitors replicas continually.  If any replica falls too far behind in
replication, pt-table-checksum pauses to allow it to catch up.  If any replica
has an error, or replication stops, pt-table-checksum pauses and waits.  In
addition, pt-table-checksum looks for common causes of problems, such as
replication filters, and refuses to operate unless you force it to.  Replication
filters are dangerous, because the queries that pt-table-checksum executes could
potentially conflict with them and cause replication to fail.
.PP
pt-table-checksum verifies that chunks are not too large to checksum safely. It
performs an \s-1EXPLAIN\s0 query on each chunk, and skips chunks that might be larger
than the desired number of rows. You can configure the sensitivity of this
safeguard with the \*(L"\-\-chunk\-size\-limit\*(R" option. If a table will be
checksummed in a single chunk because it has a small number of rows, then
pt-table-checksum additionally verifies that the table isn't oversized on
replicas.  This avoids the following scenario: a table is empty on the master
but is very large on a replica, and is checksummed in a single large query,
which causes a very long delay in replication.
.PP
There are several other safeguards. For example, pt-table-checksum sets its
session-level innodb_lock_wait_timeout to 1 second, so that if there is a lock
wait, it will be the victim instead of causing other queries to time out.
Another safeguard checks the load on the database server, and pauses if the load
is too high. There is no single right answer for how to do this, but by default
pt-table-checksum will pause if there are more than 25 concurrently executing
queries.  You should probably set a sane value for your server with the
\&\*(L"\-\-max\-load\*(R" option.
.PP
Checksumming usually is a low-priority task that should yield to other work on
the server. However, a tool that must be restarted constantly is difficult to
use.  Thus, pt-table-checksum is very resilient to errors.  For example, if the
database administrator needs to kill pt-table-checksum's queries for any reason,
that is not a fatal error.  Users often run pt-kill to kill any long-running
checksum queries. The tool will retry a killed query once, and if it fails
again, it will move on to the next chunk of that table.  The same behavior
applies if there is a lock wait timeout.  The tool will print a warning if such
an error happens, but only once per table.  If the connection to any server
fails, pt-table-checksum will attempt to reconnect and continue working.
.PP
If pt-table-checksum encounters a condition that causes it to stop completely,
it is easy to resume it with the \*(L"\-\-resume\*(R" option. It will begin from the
last chunk of the last table that it processed.  You can also safely stop the
tool with CTRL-C.  It will finish the chunk it is currently processing, and then
exit.  You can resume it as usual afterwards.
.PP
After pt-table-checksum finishes checksumming all of the chunks in a table, it
pauses and waits for all detected replicas to finish executing the checksum
queries.  Once that is finished, it checks all of the replicas to see if they
have the same data as the master, and then prints a line of output with the
results.  You can see a sample of its output later in this documentation.
.PP
The tool prints progress indicators during time-consuming operations.  It prints
a progress indicator as each table is checksummed.  The progress is computed by
the estimated number of rows in the table. It will also print a progress report
when it pauses to wait for replication to catch up, and when it is waiting to
check replicas for differences from the master.  You can make the output less
verbose with the \*(L"\-\-quiet\*(R" option.
.PP
If you wish, you can query the checksum tables manually to get a report of which
tables and chunks have differences from the master.  The following query will
report every database and table with differences, along with a summary of the
number of chunks and rows possibly affected:
.PP
.Vb 7
\&  SELECT db, tbl, SUM(this_cnt) AS total_rows, COUNT(*) AS chunks
\&  FROM percona.checksums
\&  WHERE (
\&   master_cnt <> this_cnt
\&   OR master_crc <> this_crc
\&   OR ISNULL(master_crc) <> ISNULL(this_crc))
\&  GROUP BY db, tbl;
.Ve
.PP
The table referenced in that query is the checksum table, where the checksums
are stored.  Each row in the table contains the checksum of one chunk of data
from some table in the server.
.PP
Version 2.0 of pt-table-checksum is not backwards compatible with pt-table-sync
version 1.0.  In some cases this is not a serious problem.  Adding a
\&\*(L"boundaries\*(R" column to the table, and then updating it with a manually generated
\&\s-1WHERE\s0 clause, may suffice to let pt-table-sync version 1.0 interoperate with
pt-table-checksum version 2.0.  Assuming an integer primary key named 'id', You
can try something like the following:
.PP
.Vb 4
\&  ALTER TABLE checksums ADD boundaries VARCHAR(500);
\&  UPDATE checksums
\&   SET boundaries = COALESCE(CONCAT(\*(Aqid BETWEEN \*(Aq, lower_boundary,
\&      \*(Aq AND \*(Aq, upper_boundary), \*(Aq1=1\*(Aq);
.Ve
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
.IP "Replicas using row-based replication" 4
.IX Item "Replicas using row-based replication"
pt-table-checksum requires statement-based replication, and it sets
\&\f(CW\*(C`binlog_format=STATEMENT\*(C'\fR on the master, but due to a MySQL limitation
replicas do not honor this change.  Therefore, checksums will not replicate
past any replicas using row-based replication that are masters for
further replicas.
.Sp
The tool automatically checks the \f(CW\*(C`binlog_format\*(C'\fR on all servers.
See \*(L"\-\-[no]check\-binlog\-format\*(R" .
.Sp
(Bug 899415 <https://bugs.launchpad.net/percona-toolkit/+bug/899415>)
.IP "Schema and table differences" 4
.IX Item "Schema and table differences"
The tool presumes that schemas and tables are identical on the master and
all replicas.  Replication will break if, for example, a replica does not
have a schema that exists on the master (and that schema is checksummed),
or if the structure of a table on a replica is different than on the master.
.SH "Percona XtraDB Cluster"
.IX Header "Percona XtraDB Cluster"
pt-table-checksum works with Percona XtraDB Cluster (\s-1PXC\s0) 5.5.28\-23.7 and newer.
The number of possible Percona XtraDB Cluster setups is large given that
it can be used with regular replication as well.  Therefore, only the setups
listed below are supported and known to work.  Other setups, like cluster
to cluster, are not support and probably don't work.
.PP
Except where noted, all of the following supported setups require that you
use the \f(CW\*(C`dsn\*(C'\fR method for \*(L"\-\-recursion\-method\*(R" to specify cluster nodes.
Also, the lag check (see \*(L"\s-1REPLICA CHECKS\*(R"\s0) is not performed for cluster
nodes.
.IP "Single cluster" 4
.IX Item "Single cluster"
The simplest \s-1PXC\s0 setup is a single cluster: all servers are cluster nodes,
and there are no regular replicas.  If all nodes are specified in the
\&\s-1DSN\s0 table (see \*(L"\-\-recursion\-method\*(R"), then you can run the tool on any
node and any diffs on any other nodes will be detected.
.Sp
All nodes must be in the same cluster (have the same \f(CW\*(C`wsrep_cluster_name\*(C'\fR
value), else the tool exits with an error.  Although it's possible to have
different clusters with the same name, this should not be done and is not
supported.  This applies to all supported setups.
.IP "Single cluster with replicas" 4
.IX Item "Single cluster with replicas"
Cluster nodes can also be regular masters and replicate to regular replicas.
However, the tool can only detect diffs on a replica if ran on the replica's
\&\*(L"master node\*(R".  For example, if the cluster setup is,
.Sp
.Vb 4
\&   node1 <\-> node2 <\-> node3
\&               |         |
\&               |         +\-> replica3
\&               +\-> replica2
.Ve
.Sp
you can detect diffs on replica3 by running the tool on node3, but to detect
diffs on replica2 you must run the tool again on node2.  If you run the tool
on node1, it will not detect diffs on either replica.
.Sp
Currently, the tool does not detect this setup or warn about replicas that
cannot be checked (e.g. replica2 when running on node3).
.Sp
Replicas in this setup are still subject to \*(L"\-\-[no]check\-binlog\-format\*(R".
.IP "Master to single cluster" 4
.IX Item "Master to single cluster"
It is possible for a regular master to replicate to a cluster, as if the
cluster were one logical slave, like:
.Sp
.Vb 1
\&   master \-> node1 <\-> node2 <\-> node3
.Ve
.Sp
The tool supports this setup but only if ran on the master and if all nodes
in the cluster are consistent with the \*(L"direct replica\*(R" (node1 in this example)
of the master.  For example, if all nodes have value \*(L"foo\*(R" for row 1 but
the master has value \*(L"bar\*(R" for the same row, this diff will be detected.
Or if only node1 has this diff, it will also be detected.  But if only node2
or node3 has this diff, it will not be detected.  Therefore, this setup is
used to check that the master and the cluster as a whole are consistent.
.Sp
In this setup, the tool can automatically detect the \*(L"direct replica\*(R" (node1)
when ran on the master, so you do not have to use the \f(CW\*(C`dsn\*(C'\fR method for
\&\*(L"\-\-recursion\-method\*(R" because node1 will represent the entire cluster,
which is why all other nodes must be consistent with it.
.Sp
The tool warns when it detects this setup to remind you that it only works
when used as described above.  These warnings do not affect the exit status
of the tool; they're only reminders to help avoid false-positive results.
.SH "OUTPUT"
.IX Header "OUTPUT"
The tool prints tabular results, one line per table:
.PP
.Vb 5
\&              TS ERRORS  DIFFS  ROWS  CHUNKS SKIPPED    TIME TABLE
\&  10\-20T08:36:50      0      0   200       1       0   0.005 db1.tbl1
\&  10\-20T08:36:50      0      0   603       7       0   0.035 db1.tbl2
\&  10\-20T08:36:50      0      0    16       1       0   0.003 db2.tbl3
\&  10\-20T08:36:50      0      0   600       6       0   0.024 db2.tbl4
.Ve
.PP
Errors, warnings, and progress reports are printed to standard error.  See also
\&\*(L"\-\-quiet\*(R".
.PP
Each table's results are printed when the tool finishes checksumming the table.
The columns are as follows:
.IP "\s-1TS\s0" 4
.IX Item "TS"
The timestamp (without the year) when the tool finished checksumming the table.
.IP "\s-1ERRORS\s0" 4
.IX Item "ERRORS"
The number of errors and warnings that occurred while checksumming the table.
Errors and warnings are printed to standard error while the table is in
progress.
.IP "\s-1DIFFS\s0" 4
.IX Item "DIFFS"
The number of chunks that differ from the master on one or more replicas.
If \f(CW\*(C`\-\-no\-replicate\-check\*(C'\fR is specified, this column will always have zeros.
If \*(L"\-\-replicate\-check\-only\*(R" is specified, then only tables with differences
are printed.
.IP "\s-1ROWS\s0" 4
.IX Item "ROWS"
The number of rows selected and checksummed from the table.  It might be
different from the number of rows in the table if you use the \-\-where option.
.IP "\s-1CHUNKS\s0" 4
.IX Item "CHUNKS"
The number of chunks into which the table was divided.
.IP "\s-1SKIPPED\s0" 4
.IX Item "SKIPPED"
The number of chunks that were skipped due one or more of these problems:
.Sp
.Vb 5
\&   * MySQL not using the \-\-chunk\-index
\&   * MySQL not using the full chunk index (\-\-[no]check\-plan)
\&   * Chunk size is greater than \-\-chunk\-size * \-\-chunk\-size\-limit
\&   * Lock wait timeout exceeded (\-\-retries)
\&   * Checksum query killed (\-\-retries)
.Ve
.Sp
As of pt-table-checksum 2.2.5, skipped chunks cause a non-zero \*(L"\s-1EXIT STATUS\*(R"\s0.
.IP "\s-1TIME\s0" 4
.IX Item "TIME"
The time elapsed while checksumming the table.
.IP "\s-1TABLE\s0" 4
.IX Item "TABLE"
The database and table that was checksummed.
.PP
If \*(L"\-\-replicate\-check\-only\*(R" is specified, only checksum differences on
detected replicas are printed.  The output is different: one paragraph per
replica, one checksum difference per line, and values are separated by spaces:
.PP
.Vb 4
\&  Differences on h=127.0.0.1,P=12346
\&  TABLE CHUNK CNT_DIFF CRC_DIFF CHUNK_INDEX LOWER_BOUNDARY UPPER_BOUNDARY
\&  db1.tbl1 1 0 1 PRIMARY 1 100
\&  db1.tbl1 6 0 1 PRIMARY 501 600
\&
\&  Differences on h=127.0.0.1,P=12347
\&  TABLE CHUNK CNT_DIFF CRC_DIFF CHUNK_INDEX LOWER_BOUNDARY UPPER_BOUNDARY
\&  db1.tbl1 1 0 1 PRIMARY 1 100
\&  db2.tbl2 9 5 0 PRIMARY 101 200
.Ve
.PP
The first line of a paragraph indicates the replica with differences.
In this example there are two: h=127.0.0.1,P=12346 and h=127.0.0.1,P=12347.
The columns are as follows:
.IP "\s-1TABLE\s0" 4
.IX Item "TABLE"
The database and table that differs from the master.
.IP "\s-1CHUNK\s0" 4
.IX Item "CHUNK"
The chunk number of the table that differs from the master.
.IP "\s-1CNT_DIFF\s0" 4
.IX Item "CNT_DIFF"
The number of chunk rows on the replica minus the number of chunk rows
on the master.
.IP "\s-1CRC_DIFF\s0" 4
.IX Item "CRC_DIFF"
1 if the \s-1CRC\s0 of the chunk on the replica is different than the \s-1CRC\s0 of the
chunk on the master, else 0.
.IP "\s-1CHUNK_INDEX\s0" 4
.IX Item "CHUNK_INDEX"
The index used to chunk the table.
.IP "\s-1LOWER_BOUNDARY\s0" 4
.IX Item "LOWER_BOUNDARY"
The index values that define the lower boundary of the chunk.
.IP "\s-1UPPER_BOUNDARY\s0" 4
.IX Item "UPPER_BOUNDARY"
The index values that define the upper boundary of the chunk.
.SH "EXIT STATUS"
.IX Header "EXIT STATUS"
pt-table-checksum has three possible exit statuses: zero, 255, and any other
value is a bitmask with flags for different problems.
.PP
A zero exit status indicates no errors, warnings, or checksum differences,
or skipped chunks or tables.
.PP
A 255 exit status indicates a fatal error.  In other words: the tool died
or crashed.  The error is printed to \f(CW\*(C`STDERR\*(C'\fR.
.PP
If the exit status is not zero or 255, then its value functions as a bitmask
with these flags:
.PP
.Vb 9
\&   FLAG              BIT VALUE  MEANING
\&   ================  =========  ==========================================
\&   ERROR                     1  A non\-fatal error occurred
\&   ALREADY_RUNNING           2  \-\-pid file exists and the PID is running
\&   CAUGHT_SIGNAL             4  Caught SIGHUP, SIGINT, SIGPIPE, or SIGTERM
\&   NO_SLAVES_FOUND           8  No replicas or cluster nodes were found
\&   TABLE_DIFF               16  At least one diff was found
\&   SKIP_CHUNK               32  At least one chunk was skipped
\&   SKIP_TABLE               64  At least one table was skipped
.Ve
.PP
If any flag is set, the exit status will be non-zero.  Use the bitwise \f(CW\*(C`AND\*(C'\fR
operation to check for a particular flag.  For example, if \f(CW\*(C`$exit_status & 16\*(C'\fR
is true, then at least one diff was found.
.PP
As of pt-table-checksum 2.2.5, skipped chunks cause a non-zero exit status.
An exit status of zero or 32 is equivalent to a zero exit status with skipped
chunks in previous versions of the tool.
.SH "OPTIONS"
.IX Header "OPTIONS"
This tool accepts additional command-line arguments.  Refer to the
\&\*(L"\s-1SYNOPSIS\*(R"\s0 and usage information for details.
.IP "\-\-ask\-pass" 4
.IX Item "--ask-pass"
group: Connection
.Sp
Prompt for a password when connecting to MySQL.
.IP "\-\-[no]check\-binlog\-format" 4
.IX Item "--[no]check-binlog-format"
default: yes
.Sp
Check that the \f(CW\*(C`binlog_format\*(C'\fR is the same on all servers.
.Sp
See \*(L"Replicas using row-based replication\*(R" under \*(L"\s-1LIMITATIONS\*(R"\s0.
.IP "\-\-binary\-index" 4
.IX Item "--binary-index"
This option modifies the behavior of \*(L"\-\-create\-replicate\-table\*(R" such that the
replicate table's upper and lower boundary columns are created with the \s-1BLOB\s0 
data type.
This is useful in cases where you have trouble checksuming tables with keys that 
include a binary data type or that have non-standard character sets.
See \*(L"\-\-replicate\*(R".
.IP "\-\-check\-interval" 4
.IX Item "--check-interval"
type: time; default: 1; group: Throttle
.Sp
Sleep time between checks for \*(L"\-\-max\-lag\*(R".
.IP "\-\-[no]check\-plan" 4
.IX Item "--[no]check-plan"
default: yes
.Sp
Check query execution plans for safety. By default, this option causes
pt-table-checksum to run \s-1EXPLAIN\s0 before running queries that are meant to access
a small amount of data, but which could access many rows if MySQL chooses a bad
execution plan. These include the queries to determine chunk boundaries and the
chunk queries themselves. If it appears that MySQL will use a bad query
execution plan, the tool will skip the chunk of the table.
.Sp
The tool uses several heuristics to determine whether an execution plan is bad.
The first is whether \s-1EXPLAIN\s0 reports that MySQL intends to use the desired index
to access the rows. If MySQL chooses a different index, the tool considers the
query unsafe.
.Sp
The tool also checks how much of the index MySQL reports that it will use for
the query. The \s-1EXPLAIN\s0 output shows this in the key_len column. The tool
remembers the largest key_len seen, and skips chunks where MySQL reports that it
will use a smaller prefix of the index. This heuristic can be understood as
skipping chunks that have a worse execution plan than other chunks.
.Sp
The tool prints a warning the first time a chunk is skipped due to
a bad execution plan in each table. Subsequent chunks are skipped silently,
although you can see the count of skipped chunks in the \s-1SKIPPED\s0 column in
the tool's output.
.Sp
This option adds some setup work to each table and chunk. Although the work is
not intrusive for MySQL, it results in more round-trips to the server, which
consumes time. Making chunks too small will cause the overhead to become
relatively larger. It is therefore recommended that you not make chunks too
small, because the tool may take a very long time to complete if you do.
.IP "\-\-[no]check\-replication\-filters" 4
.IX Item "--[no]check-replication-filters"
default: yes; group: Safety
.Sp
Do not checksum if any replication filters are set on any replicas.
The tool looks for server options that filter replication, such as
binlog_ignore_db and replicate_do_db.  If it finds any such filters,
it aborts with an error.
.Sp
If the replicas are configured with any filtering options, you should be careful
not to checksum any databases or tables that exist on the master and not the
replicas.  Changes to such tables might normally be skipped on the replicas
because of the filtering options, but the checksum queries modify the contents
of the table that stores the checksums, not the tables whose data you are
checksumming.  Therefore, these queries will be executed on the replica, and if
the table or database you're checksumming does not exist, the queries will cause
replication to fail.  For more information on replication rules, see
<http://dev.mysql.com/doc/en/replication\-rules.html>.
.Sp
Replication filtering makes it impossible to be sure that the checksum queries
won't break replication (or simply fail to replicate).  If you are sure that
it's \s-1OK\s0 to run the checksum queries, you can negate this option to disable the
checks.  See also \*(L"\-\-replicate\-database\*(R".
.Sp
See also \*(L"\s-1REPLICA CHECKS\*(R"\s0.
.IP "\-\-check\-slave\-lag" 4
.IX Item "--check-slave-lag"
type: string; group: Throttle
.Sp
Pause checksumming until this replica's lag is less than \*(L"\-\-max\-lag\*(R".  The
value is a \s-1DSN\s0 that inherits properties from the master host and the connection
options (\*(L"\-\-port\*(R", \*(L"\-\-user\*(R", etc.).  By default, pt-table-checksum
monitors lag on all connected replicas, but this option limits lag monitoring
to the specified replica.  This is useful if certain replicas are intentionally
lagged (with pt-slave-delay for example), in which case you can specify
a normal replica to monitor.
.Sp
See also \*(L"\s-1REPLICA CHECKS\*(R"\s0.
.IP "\-\-[no]check\-slave\-tables" 4
.IX Item "--[no]check-slave-tables"
default: yes; group: Safety
.Sp
Checks that tables on slaves exist and have all the checksum \*(L"\-\-columns\*(R".
Tables missing on slaves or not having all the checksum \*(L"\-\-columns\*(R" can
cause the tool to break replication when it tries to check for differences.
Only disable this check if you are aware of the risks and are sure that all
tables on all slaves exist and are identical to the master.
.IP "\-\-chunk\-index" 4
.IX Item "--chunk-index"
type: string
.Sp
Prefer this index for chunking tables.  By default, pt-table-checksum chooses
the most appropriate index for chunking.  This option lets you specify the index
that you prefer.  If the index doesn't exist, then pt-table-checksum will fall
back to its default behavior of choosing an index.  pt-table-checksum adds the
index to the checksum \s-1SQL\s0 statements in a \f(CW\*(C`FORCE INDEX\*(C'\fR clause.  Be careful
when using this option; a poor choice of index could cause bad performance.
This is probably best to use when you are checksumming only a single table, not
an entire server.
.IP "\-\-chunk\-index\-columns" 4
.IX Item "--chunk-index-columns"
type: int
.Sp
Use only this many left-most columns of a \*(L"\-\-chunk\-index\*(R".  This works
only for compound indexes, and is useful in cases where a bug in the MySQL
query optimizer (planner) causes it to scan a large range of rows instead
of using the index to locate starting and ending points precisely.  This
problem sometimes occurs on indexes with many columns, such as 4 or more.
If this happens, the tool might print a warning related to the
\&\*(L"\-\-[no]check\-plan\*(R" option.  Instructing the tool to use only the first
N columns of the index is a workaround for the bug in some cases.
.IP "\-\-chunk\-size" 4
.IX Item "--chunk-size"
type: size; default: 1000
.Sp
Number of rows to select for each checksum query.  Allowable suffixes are
k, M, G.  You should not use this option in most cases; prefer \*(L"\-\-chunk\-time\*(R"
instead.
.Sp
This option can override the default behavior, which is to adjust chunk size
dynamically to try to make chunks run in exactly \*(L"\-\-chunk\-time\*(R" seconds.
When this option isn't set explicitly, its default value is used as a starting
point, but after that, the tool ignores this option's value.  If you set this
option explicitly, however, then it disables the dynamic adjustment behavior and
tries to make all chunks exactly the specified number of rows.
.Sp
There is a subtlety: if the chunk index is not unique, then it's possible that
chunks will be larger than desired. For example, if a table is chunked by an
index that contains 10,000 of a given value, there is no way to write a \s-1WHERE\s0
clause that matches only 1,000 of the values, and that chunk will be at least
10,000 rows large.  Such a chunk will probably be skipped because of
\&\*(L"\-\-chunk\-size\-limit\*(R".
.Sp
Selecting a small chunk size will cause the tool to become much slower, in part
because of the setup work required for \*(L"\-\-[no]check\-plan\*(R".
.IP "\-\-chunk\-size\-limit" 4
.IX Item "--chunk-size-limit"
type: float; default: 2.0; group: Safety
.Sp
Do not checksum chunks this much larger than the desired chunk size.
.Sp
When a table has no unique indexes, chunk sizes can be inaccurate.  This option
specifies a maximum tolerable limit to the inaccuracy.  The tool uses <\s-1EXPLAIN\s0>
to estimate how many rows are in the chunk.  If that estimate exceeds the
desired chunk size times the limit (twice as large, by default), then the tool
skips the chunk.
.Sp
The minimum value for this option is 1, which means that no chunk can be larger
than \*(L"\-\-chunk\-size\*(R".  You probably don't want to specify 1, because rows
reported by \s-1EXPLAIN\s0 are estimates, which can be different from the real number
of rows in the chunk.  If the tool skips too many chunks because they are
oversized, you might want to specify a value larger than the default of 2.
.Sp
You can disable oversized chunk checking by specifying a value of 0.
.IP "\-\-chunk\-time" 4
.IX Item "--chunk-time"
type: float; default: 0.5
.Sp
Adjust the chunk size dynamically so each checksum query takes this long to execute.
.Sp
The tool tracks the checksum rate (rows per second) for all tables and each
table individually.  It uses these rates to adjust the chunk size after each
checksum query, so that the next checksum query takes this amount of time (in
seconds) to execute.
.Sp
The algorithm is as follows: at the beginning of each table, the chunk size is
initialized from the overall average rows per second since the tool began
working, or the value of \*(L"\-\-chunk\-size\*(R" if the tool hasn't started working
yet. For each subsequent chunk of a table, the tool adjusts the chunk size to
try to make queries run in the desired amount of time.  It keeps an
exponentially decaying moving average of queries per second, so that if the
server's performance changes due to changes in server load, the tool adapts
quickly.  This allows the tool to achieve predictably timed queries for each
table, and for the server overall.
.Sp
If this option is set to zero, the chunk size doesn't auto-adjust, so query
checksum times will vary, but query checksum sizes will not. Another way to do
the same thing is to specify a value for \*(L"\-\-chunk\-size\*(R" explicitly, instead
of leaving it at the default.
.IP "\-\-columns" 4
.IX Item "--columns"
short form: \-c; type: array; group: Filter
.Sp
Checksum only this comma-separated list of columns.  If a table doesn't have
any of the specified columns it will be skipped.
.Sp
This option applies to all tables, so it really only makes sense when
checksumming one table unless the tables have a common set of columns.
.IP "\-\-config" 4
.IX Item "--config"
type: Array; group: Config
.Sp
Read this comma-separated list of config files; if specified, this must be the
first option on the command line.
.Sp
See the \*(L"\-\-help\*(R" output for a list of default config files.
.IP "\-\-[no]create\-replicate\-table" 4
.IX Item "--[no]create-replicate-table"
default: yes
.Sp
Create the \*(L"\-\-replicate\*(R" database and table if they do not exist.
The structure of the replicate table is the same as the suggested table
mentioned in \*(L"\-\-replicate\*(R".
.IP "\-\-databases" 4
.IX Item "--databases"
short form: \-d; type: hash; group: Filter
.Sp
Only checksum this comma-separated list of databases.
.IP "\-\-databases\-regex" 4
.IX Item "--databases-regex"
type: string; group: Filter
.Sp
Only checksum databases whose names match this Perl regex.
.IP "\-\-defaults\-file" 4
.IX Item "--defaults-file"
short form: \-F; type: string; group: Connection
.Sp
Only read mysql options from the given file.  You must give an absolute
pathname.
.IP "\-\-[no]empty\-replicate\-table" 4
.IX Item "--[no]empty-replicate-table"
default: yes
.Sp
Delete previous checksums for each table before checksumming the table.  This
option does not truncate the entire table, it only deletes rows (checksums) for
each table just before checksumming the table.  Therefore, if checksumming stops
prematurely and there was preexisting data, there will still be rows for tables
that were not checksummed before the tool was stopped.
.Sp
If you're resuming from a previous checksum run, then the checksum records for
the table from which the tool resumes won't be emptied.
.Sp
To empty the entire replicate table, you must manually execute \f(CW\*(C`TRUNCATE TABLE\*(C'\fR
before running the tool.
.IP "\-\-engines" 4
.IX Item "--engines"
short form: \-e; type: hash; group: Filter
.Sp
Only checksum tables which use these storage engines.
.IP "\-\-explain" 4
.IX Item "--explain"
cumulative: yes; default: 0; group: Output
.Sp
Show, but do not execute, checksum queries (disables
\&\*(L"\-\-[no]empty\-replicate\-table\*(R").  If specified twice, the tool actually
iterates through the chunking algorithm, printing the upper and lower boundary
values for each chunk, but not executing the checksum queries.
.IP "\-\-float\-precision" 4
.IX Item "--float-precision"
type: int
.Sp
Precision for \s-1FLOAT\s0 and \s-1DOUBLE\s0 number-to-string conversion.  Causes \s-1FLOAT\s0
and \s-1DOUBLE\s0 values to be rounded to the specified number of digits after the
decimal point, with the \s-1\fBROUND\s0()\fR function in MySQL.  This can help avoid
checksum mismatches due to different floating-point representations of the same
values on different MySQL versions and hardware.  The default is no rounding;
the values are converted to strings by the \s-1\fBCONCAT\s0()\fR function, and MySQL chooses
the string representation.  If you specify a value of 2, for example, then the
values 1.008 and 1.009 will be rounded to 1.01, and will checksum as equal.
.IP "\-\-function" 4
.IX Item "--function"
type: string
.Sp
Hash function for checksums (\s-1FNV1A_64, MURMUR_HASH, SHA1, MD5, CRC32,\s0 etc).
.Sp
The default is to use \s-1\fBCRC32\s0()\fR, but \s-1\fBMD5\s0()\fR and \s-1\fBSHA1\s0()\fR also work, and you
can use your own function, such as a compiled \s-1UDF,\s0 if you wish.  The
function you specify is run in \s-1SQL,\s0 not in Perl, so it must be available
to MySQL.
.Sp
MySQL doesn't have good built-in hash functions that are fast.  \s-1\fBCRC32\s0()\fR is too
prone to hash collisions, and \s-1\fBMD5\s0()\fR and \s-1\fBSHA1\s0()\fR are very CPU-intensive. The
\&\s-1\fBFNV1A_64\s0()\fR \s-1UDF\s0 that is distributed with Percona Server is a faster alternative.
It is very simple to compile and install; look at the header in the source code
for instructions.  If it is installed, it is preferred over \s-1\fBMD5\s0()\fR.  You can also
use the \s-1\fBMURMUR_HASH\s0()\fR function if you compile and install that as a \s-1UDF\s0; the
source is also distributed with Percona Server, and it might be better than
\&\s-1\fBFNV1A_64\s0()\fR.
.IP "\-\-help" 4
.IX Item "--help"
group: Help
.Sp
Show help and exit.
.IP "\-\-host" 4
.IX Item "--host"
short form: \-h; type: string; default: localhost; group: Connection
.Sp
Host to connect to.
.IP "\-\-ignore\-columns" 4
.IX Item "--ignore-columns"
type: Hash; group: Filter
.Sp
Ignore this comma-separated list of columns when calculating the checksum.
If a table has all of its columns filtered by \-\-ignore\-columns, it will
be skipped.
.IP "\-\-ignore\-databases" 4
.IX Item "--ignore-databases"
type: Hash; group: Filter
.Sp
Ignore this comma-separated list of databases.
.IP "\-\-ignore\-databases\-regex" 4
.IX Item "--ignore-databases-regex"
type: string; group: Filter
.Sp
Ignore databases whose names match this Perl regex.
.IP "\-\-ignore\-engines" 4
.IX Item "--ignore-engines"
type: Hash; default: \s-1FEDERATED\s0,MRG_MyISAM; group: Filter
.Sp
Ignore this comma-separated list of storage engines.
.IP "\-\-ignore\-tables" 4
.IX Item "--ignore-tables"
type: Hash; group: Filter
.Sp
Ignore this comma-separated list of tables.  Table names may be qualified with
the database name.  The \*(L"\-\-replicate\*(R" table is always automatically ignored.
.IP "\-\-ignore\-tables\-regex" 4
.IX Item "--ignore-tables-regex"
type: string; group: Filter
.Sp
Ignore tables whose names match the Perl regex.
.IP "\-\-max\-lag" 4
.IX Item "--max-lag"
type: time; default: 1s; group: Throttle
.Sp
Pause checksumming until all replicas' lag is less than this value.  After each
checksum query (each chunk), pt-table-checksum looks at the replication lag of
all replicas to which it connects, using Seconds_Behind_Master. If any replica
is lagging more than the value of this option, then pt-table-checksum will sleep
for \*(L"\-\-check\-interval\*(R" seconds, then check all replicas again.  If you
specify \*(L"\-\-check\-slave\-lag\*(R", then the tool only examines that server for
lag, not all servers.
.Sp
The tool waits forever for replicas to stop lagging.  If any replica is
stopped, the tool waits forever until the replica is started.  Checksumming
continues once all replicas are running and not lagging too much.
.Sp
The tool prints progress reports while waiting.  If a replica is stopped, it
prints a progress report immediately, then again at every progress report
interval.
.Sp
See also \*(L"\s-1REPLICA CHECKS\*(R"\s0.
.IP "\-\-max\-load" 4
.IX Item "--max-load"
type: Array; default: Threads_running=25; group: Throttle
.Sp
Examine \s-1SHOW GLOBAL STATUS\s0 after every chunk, and pause if any status variables
are higher than the threshold.  The option accepts a comma-separated list of
MySQL status variables to check for a threshold.  An optional \f(CW\*(C`=MAX_VALUE\*(C'\fR (or
\&\f(CW\*(C`:MAX_VALUE\*(C'\fR) can follow each variable.  If not given, the tool determines a
threshold by examining the current value and increasing it by 20%.
.Sp
For example, if you want the tool to pause when Threads_connected gets too high,
you can specify \*(L"Threads_connected\*(R", and the tool will check the current value
when it starts working and add 20% to that value.  If the current value is 100,
then the tool will pause when Threads_connected exceeds 120, and resume working
when it is below 120 again.  If you want to specify an explicit threshold, such
as 110, you can use either \*(L"Threads_connected:110\*(R" or \*(L"Threads_connected=110\*(R".
.Sp
The purpose of this option is to prevent the tool from adding too much load to
the server. If the checksum queries are intrusive, or if they cause lock waits,
then other queries on the server will tend to block and queue. This will
typically cause Threads_running to increase, and the tool can detect that by
running \s-1SHOW GLOBAL STATUS\s0 immediately after each checksum query finishes.  If
you specify a threshold for this variable, then you can instruct the tool to
wait until queries are running normally again.  This will not prevent queueing,
however; it will only give the server a chance to recover from the queueing.  If
you notice queueing, it is best to decrease the chunk time.
.IP "\-\-password" 4
.IX Item "--password"
short form: \-p; type: string; group: Connection
.Sp
Password to use when connecting.
If password contains commas they must be escaped with a backslash: \*(L"exam\e,ple\*(R"
.IP "\-\-pid" 4
.IX Item "--pid"
type: string
.Sp
Create the given \s-1PID\s0 file.  The tool won't start if the \s-1PID\s0 file already
exists and the \s-1PID\s0 it contains is different than the current \s-1PID.\s0  However,
if the \s-1PID\s0 file exists and the \s-1PID\s0 it contains is no longer running, the
tool will overwrite the \s-1PID\s0 file with the current \s-1PID.\s0  The \s-1PID\s0 file is
removed automatically when the tool exits.
.IP "\-\-plugin" 4
.IX Item "--plugin"
type: string
.Sp
Perl module file that defines a \f(CW\*(C`pt_table_checksum_plugin\*(C'\fR class.
A plugin allows you to write a Perl module that can hook into many parts
of pt-table-checksum.  This requires a good knowledge of Perl and
Percona Toolkit conventions, which are beyond this scope of this
documentation.  Please contact Percona if you have questions or need help.
.Sp
See \*(L"\s-1PLUGIN\*(R"\s0 for more information.
.IP "\-\-port" 4
.IX Item "--port"
short form: \-P; type: int; group: Connection
.Sp
Port number to use for connection.
.IP "\-\-progress" 4
.IX Item "--progress"
type: array; default: time,30
.Sp
Print progress reports to \s-1STDERR.\s0
.Sp
The value is a comma-separated list with two parts.  The first part can be
percentage, time, or iterations; the second part specifies how often an update
should be printed, in percentage, seconds, or number of iterations.  The tool
prints progress reports for a variety of time-consuming operations, including
waiting for replicas to catch up if they become lagged.
.IP "\-\-quiet" 4
.IX Item "--quiet"
short form: \-q; cumulative: yes; default: 0
.Sp
Print only the most important information (disables \*(L"\-\-progress\*(R").
Specifying this option once causes the tool to print only errors, warnings, and
tables that have checksum differences.
.Sp
Specifying this option twice causes the tool to print only errors.  In this
case, you can use the tool's exit status to determine if there were any warnings
or checksum differences.
.IP "\-\-recurse" 4
.IX Item "--recurse"
type: int
.Sp
Number of levels to recurse in the hierarchy when discovering replicas.
Default is infinite.  See also \*(L"\-\-recursion\-method\*(R" and \*(L"\s-1REPLICA CHECKS\*(R"\s0.
.IP "\-\-recursion\-method" 4
.IX Item "--recursion-method"
type: array; default: processlist,hosts
.Sp
Preferred recursion method for discovering replicas.  pt-table-checksum
performs several \*(L"\s-1REPLICA CHECKS\*(R"\s0 before and while running.
.Sp
Although replicas are not required to run pt-table-checksum, the tool
cannot detect diffs on slaves that it cannot discover.  Therefore,
a warning is printed and the \*(L"\s-1EXIT STATUS\*(R"\s0 is non-zero if no replicas 
are found and the method is not \f(CW\*(C`none\*(C'\fR.  If this happens, try a different
recursion method, or use the \f(CW\*(C`dsn\*(C'\fR method to specify the replicas to check.
.Sp
Possible methods are:
.Sp
.Vb 7
\&  METHOD       USES
\&  ===========  =============================================
\&  processlist  SHOW PROCESSLIST
\&  hosts        SHOW SLAVE HOSTS
\&  cluster      SHOW STATUS LIKE \*(Aqwsrep\e_incoming\e_addresses\*(Aq
\&  dsn=DSN      DSNs from a table
\&  none         Do not find slaves
.Ve
.Sp
The \f(CW\*(C`processlist\*(C'\fR method is the default, because \f(CW\*(C`SHOW SLAVE HOSTS\*(C'\fR is not
reliable.  However, if the server uses a non-standard port (not 3306), then
the \f(CW\*(C`hosts\*(C'\fR method becomes the default because it works better in this case.
.Sp
The \f(CW\*(C`hosts\*(C'\fR method requires replicas to be configured with \f(CW\*(C`report_host\*(C'\fR,
\&\f(CW\*(C`report_port\*(C'\fR, etc.
.Sp
The \f(CW\*(C`cluster\*(C'\fR method requires a cluster based on Galera 23.7.3 or newer,
such as Percona XtraDB Cluster versions 5.5.29 and above.  This will
auto-discover nodes in a cluster using
\&\f(CW\*(C`SHOW STATUS LIKE \*(Aqwsrep\e_incoming\e_addresses\*(Aq\*(C'\fR.  You can combine \f(CW\*(C`cluster\*(C'\fR
with \f(CW\*(C`processlist\*(C'\fR and \f(CW\*(C`hosts\*(C'\fR to auto-discover cluster nodes and replicas,
but this functionality is experimental.
.Sp
The \f(CW\*(C`dsn\*(C'\fR method is special: rather than automatically discovering replicas,
this method specifies a table with replica DSNs.  The tool will only connect
to these replicas.  This method works best when replicas do not use the same
MySQL username or password as the master, or when you want to prevent the tool
from connecting to certain replicas.  The \f(CW\*(C`dsn\*(C'\fR method is specified like:
\&\f(CW\*(C`\-\-recursion\-method dsn=h=host,D=percona,t=dsns\*(C'\fR.  The specified \s-1DSN\s0 must
have D and t parts, or just a database-qualified t part, which specify the
\&\s-1DSN\s0 table.  The \s-1DSN\s0 table must have the following structure:
.Sp
.Vb 6
\&  CREATE TABLE \`dsns\` (
\&    \`id\` int(11) NOT NULL AUTO_INCREMENT,
\&    \`parent_id\` int(11) DEFAULT NULL,
\&    \`dsn\` varchar(255) NOT NULL,
\&    PRIMARY KEY (\`id\`)
\&  );
.Ve
.Sp
DSNs are ordered by \f(CW\*(C`id\*(C'\fR, but \f(CW\*(C`id\*(C'\fR and \f(CW\*(C`parent_id\*(C'\fR are otherwise ignored.
The \f(CW\*(C`dsn\*(C'\fR column contains a replica \s-1DSN\s0 like it would be given on the command
line, for example: \f(CW"h=replica_host,u=repl_user,p=repl_pass"\fR.
.Sp
The \f(CW\*(C`none\*(C'\fR method makes the tool ignore all slaves and cluster nodes. This 
method is not recommended because it effectively disables the 
\&\*(L"\s-1REPLICA CHECKS\*(R"\s0 and no differences can be found. It is useful, however, if 
you only need to write checksums on the master or a single cluster node. The 
safer alternative is \f(CW\*(C`\-\-no\-replicate\-check\*(C'\fR: the tool finds replicas and 
cluster nodes, performs the \*(L"\s-1REPLICA CHECKS\*(R"\s0, but does not check for 
differences. See \*(L"\-\-[no]replicate\-check\*(R".
.IP "\-\-replicate" 4
.IX Item "--replicate"
type: string; default: percona.checksums
.Sp
Write checksum results to this table.  The replicate table must have this
structure (MAGIC_create_replicate):
.Sp
.Vb 10
\&  CREATE TABLE checksums (
\&     db             CHAR(64)     NOT NULL,
\&     tbl            CHAR(64)     NOT NULL,
\&     chunk          INT          NOT NULL,
\&     chunk_time     FLOAT            NULL,
\&     chunk_index    VARCHAR(200)     NULL,
\&     lower_boundary TEXT             NULL,
\&     upper_boundary TEXT             NULL,
\&     this_crc       CHAR(40)     NOT NULL,
\&     this_cnt       INT          NOT NULL,
\&     master_crc     CHAR(40)         NULL,
\&     master_cnt     INT              NULL,
\&     ts             TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
\&     PRIMARY KEY (db, tbl, chunk),
\&     INDEX ts_db_tbl (ts, db, tbl)
\&  ) ENGINE=InnoDB;
.Ve
.Sp
Note: lower_boundary and upper_boundary data type can be \s-1BLOB.\s0 See \*(L"\-\-binary\-index\*(R".
.Sp
By default, \*(L"\-\-[no]create\-replicate\-table\*(R" is true, so the database and
the table specified by this option are created automatically if they do not
exist.
.Sp
Be sure to choose an appropriate storage engine for the replicate table.  If you
are checksumming InnoDB tables, and you use MyISAM for this table, a deadlock
will break replication, because the mixture of transactional and
non-transactional tables in the checksum statements will cause it to be written
to the binlog even though it had an error.  It will then replay without a
deadlock on the replicas, and break replication with \*(L"different error on master
and slave.\*(R"  This is not a problem with pt-table-checksum; it's a problem with
MySQL replication, and you can read more about it in the MySQL manual.
.Sp
The replicate table is never checksummed (the tool automatically adds this
table to \*(L"\-\-ignore\-tables\*(R").
.IP "\-\-[no]replicate\-check" 4
.IX Item "--[no]replicate-check"
default: yes
.Sp
Check replicas for data differences after finishing each table.  The tool finds
differences by executing a simple \s-1SELECT\s0 statement on all detected replicas.
The query compares the replica's checksum results to the master's checksum
results.  It reports differences in the \s-1DIFFS\s0 column of the output.
.IP "\-\-replicate\-check\-only" 4
.IX Item "--replicate-check-only"
Check replicas for consistency without executing checksum queries.
This option is used only with \*(L"\-\-[no]replicate\-check\*(R".  If specified,
pt-table-checksum doesn't checksum any tables.  It checks replicas for
differences found by previous checksumming, and then exits.  It might be useful
if you run pt-table-checksum quietly in a cron job, for example, and later want
a report on the results of the cron job, perhaps to implement a Nagios check.
.IP "\-\-replicate\-check\-retries" 4
.IX Item "--replicate-check-retries"
type: int; default: 1
.Sp
Retry checksum comparison this many times when a difference is encountered.
Only when a difference persists after this number of checks is it considered valid.
Using this option with a value of 2 or more alleviates spurious differences that 
arise when using the \-\-resume option.
.IP "\-\-replicate\-database" 4
.IX Item "--replicate-database"
type: string
.Sp
\&\s-1USE\s0 only this database.  By default, pt-table-checksum executes \s-1USE\s0 to select
the database that contains the table it's currently working on.  This is is a
best effort to avoid problems with replication filters such as binlog_ignore_db
and replicate_ignore_db.  However, replication filters can create a situation
where there simply is no one right way to do things.  Some statements might not
be replicated, and others might cause replication to fail.  In such cases, you
can use this option to specify a default database that pt-table-checksum selects
with \s-1USE,\s0 and never changes.  See also \*(L"\-\-[no]check\-replication\-filters\*(R".
.IP "\-\-resume" 4
.IX Item "--resume"
Resume checksumming from the last completed chunk (disables
\&\*(L"\-\-[no]empty\-replicate\-table\*(R").  If the tool stops before it checksums all
tables, this option makes checksumming resume from the last chunk of the last
table that it finished.
.IP "\-\-retries" 4
.IX Item "--retries"
type: int; default: 2
.Sp
Retry a chunk this many times when there is a nonfatal error.  Nonfatal errors
are problems such as a lock wait timeout or the query being killed.
.IP "\-\-run\-time" 4
.IX Item "--run-time"
type: time
.Sp
How long to run.  Default is to run until all tables have been checksummed.
These time value suffixes are allowed: s (seconds), m (minutes), h (hours),
and d (days).  Combine this option with \*(L"\-\-resume\*(R" to checksum as many
tables within an allotted time, resuming from where the tool left off next
time it is ran.
.IP "\-\-separator" 4
.IX Item "--separator"
type: string; default: #
.Sp
The separator character used for \s-1\fBCONCAT_WS\s0()\fR.  This character is used to join
the values of columns when checksumming.
.IP "\-\-set\-vars" 4
.IX Item "--set-vars"
type: Array; group: Connection
.Sp
Set the MySQL variables in this comma-separated list of \f(CW\*(C`variable=value\*(C'\fR pairs.
.Sp
By default, the tool sets:
.Sp
.Vb 2
\&   wait_timeout=10000
\&   innodb_lock_wait_timeout=1
.Ve
.Sp
Variables specified on the command line override these defaults.  For
example, specifying \f(CW\*(C`\-\-set\-vars wait_timeout=500\*(C'\fR overrides the defaultvalue of \f(CW10000\fR.
.Sp
The tool prints a warning and continues if a variable cannot be set.
.IP "\-\-socket" 4
.IX Item "--socket"
short form: \-S; type: string; group: Connection
.Sp
Socket file to use for connection.
.IP "\-\-slave\-skip\-tolerance" 4
.IX Item "--slave-skip-tolerance"
type: float; default: 1.0
.Sp
When a master table is marked to be checksumed in only one chunk but a slave
table exceeds the maximum accepted size for this, the table is skipped. 
Since number of rows are often rough estimates, many times tables are skipped
needlessly for very small differences.
This option provides a max row excess tolerance to prevent this.
For example a value of 1.2 will tolerate slave tables with up to 20% excess rows.
.IP "\-\-tables" 4
.IX Item "--tables"
short form: \-t; type: hash; group: Filter
.Sp
Checksum only this comma-separated list of tables.
Table names may be qualified with the database name.
.IP "\-\-tables\-regex" 4
.IX Item "--tables-regex"
type: string; group: Filter
.Sp
Checksum only tables whose names match this Perl regex.
.IP "\-\-trim" 4
.IX Item "--trim"
Add \s-1\fBTRIM\s0()\fR to \s-1VARCHAR\s0 columns (helps when comparing 4.1 to >= 5.0).
This is useful when you don't care about the trailing space differences between
MySQL versions that vary in their handling of trailing spaces. MySQL 5.0 and 
later all retain trailing spaces in \s-1VARCHAR,\s0 while previous versions would 
remove them.  These differences will cause false checksum differences.
.IP "\-\-user" 4
.IX Item "--user"
short form: \-u; type: string; group: Connection
.Sp
User for login if not current user.
.IP "\-\-version" 4
.IX Item "--version"
group: Help
.Sp
Show version and exit.
.IP "\-\-[no]version\-check" 4
.IX Item "--[no]version-check"
default: yes
.Sp
Check for the latest version of Percona Toolkit, MySQL, and other programs.
.Sp
This is a standard \*(L"check for updates automatically\*(R" feature, with two
additional features.  First, the tool checks the version of other programs
on the local system in addition to its own version.  For example, it checks
the version of every MySQL server it connects to, Perl, and the Perl module
DBD::mysql.  Second, it checks for and warns about versions with known
problems.  For example, MySQL 5.5.25 had a critical bug and was re-released
as 5.5.25a.
.Sp
Any updates or known problems are printed to \s-1STDOUT\s0 before the tool's normal
output.  This feature should never interfere with the normal operation of the
tool.
.Sp
For more information, visit <https://www.percona.com/version\-check>.
.IP "\-\-where" 4
.IX Item "--where"
type: string
.Sp
Do only rows matching this \s-1WHERE\s0 clause.  You can use this option to limit
the checksum to only part of the table.  This is particularly useful if you have
append-only tables and don't want to constantly re-check all rows; you could run
a daily job to just check yesterday's rows, for instance.
.Sp
This option is much like the \-w option to mysqldump.  Do not specify the \s-1WHERE\s0
keyword.  You might need to quote the value.  Here is an example:
.Sp
.Vb 1
\&  pt\-table\-checksum \-\-where "ts > CURRENT_DATE \- INTERVAL 1 DAY"
.Ve
.SH "REPLICA CHECKS"
.IX Header "REPLICA CHECKS"
By default, pt-table-checksum attempts to find and connect to all replicas
connected to the master host.  This automated process is called
\&\*(L"slave recursion\*(R" and is controlled by the \*(L"\-\-recursion\-method\*(R" and
\&\*(L"\-\-recurse\*(R" options.  The tool performs these checks on all replicas:
.ie n .IP "1. ""\-\-[no]check\-replication\-filters""" 4
.el .IP "1. ``\-\-[no]check\-replication\-filters''" 4
.IX Item "1. --[no]check-replication-filters"
pt-table-checksum checks for replication filters on all replicas because
they can complicate or break the checksum process.  By default, the tool
will exit if any replication filters are found, but this check can be
disabled by specifying \f(CW\*(C`\-\-no\-check\-replication\-filters\*(C'\fR.
.ie n .IP "2. ""\-\-replicate"" table" 4
.el .IP "2. ``\-\-replicate'' table" 4
.IX Item "2. --replicate table"
pt-table-checksum checks that the \*(L"\-\-replicate\*(R" table exists on all
replicas, else checksumming can break replication when updates to the table
on the master replicate to a replica that doesn't have the table.  This
check cannot be disabled, and the tool waits forever until the table
exists on all replicas, printing \*(L"\-\-progress\*(R" messages while it waits.
.IP "3. Single chunk size" 4
.IX Item "3. Single chunk size"
If a table can be checksummed in a single chunk on the master,
pt-table-checksum will check that the table size on all replicas is less than
\&\*(L"\-\-chunk\-size\*(R" * \*(L"\-\-chunk\-size\-limit\*(R". This prevents a rare problem
where the table on the master is empty or small, but on a replica it is much
larger. In this case, the single chunk checksum on the master would overload
the replica.
.Sp
Another rare problem occurs when the table size on a replica is close to
\&\*(L"\-\-chunk\-size\*(R" * \*(L"\-\-chunk\-size\-limit\*(R". In such cases, the table is more
likely to be skipped even though it's safe to checksum in a single chunk.
This happens because table sizes are estimates. When those estimates and
\&\*(L"\-\-chunk\-size\*(R" * \*(L"\-\-chunk\-size\-limit\*(R" are almost equal, this check
becomes more sensitive to the estimates' margin of error rather than actual
significant differences in table sizes. Specifying a larger value for
\&\*(L"\-\-chunk\-size\-limit\*(R" helps avoid this problem.
.Sp
This check cannot be disabled.
.IP "4. Lag" 4
.IX Item "4. Lag"
After each chunk, pt-table-checksum checks the lag on all replicas, or only
the replica specified by \*(L"\-\-check\-slave\-lag\*(R".  This helps the tool
not to overload the replicas with checksum data.  There is no way to
disable this check, but you can specify a single replica to check with
\&\*(L"\-\-check\-slave\-lag\*(R", and if that replica is the fastest, it will help
prevent the tool from waiting too long for replica lag to abate.
.IP "5. Checksum chunks" 4
.IX Item "5. Checksum chunks"
When pt-table-checksum finishes checksumming a table, it waits for the last
checksum chunk to replicate to all replicas so it can perform the
\&\*(L"\-\-[no]replicate\-check\*(R".  Disabling that option by specifying
\&\-\-no\-replicate\-check disables this check, but it also disables
immediate reporting of checksum differences, thereby requiring a second run
of the tool with \*(L"\-\-replicate\-check\-only\*(R" to find and print checksum
differences.
.SH "PLUGIN"
.IX Header "PLUGIN"
The file specified by \*(L"\-\-plugin\*(R" must define a class (i.e. a package)
called \f(CW\*(C`pt_table_checksum_plugin\*(C'\fR with a \f(CW\*(C`new()\*(C'\fR subroutine.
The tool will create an instance of this class and call any hooks that
it defines.  No hooks are required, but a plugin isn't very useful without
them.
.PP
These hooks, in this order, are called if defined:
.PP
.Vb 6
\&   init
\&   before_replicate_check
\&   after_replicate_check
\&   get_slave_lag
\&   before_checksum_table
\&   after_checksum_table
.Ve
.PP
Each hook is passed different arguments.  To see which arguments are passed
to a hook, search for the hook's name in the tool's source code, like:
.PP
.Vb 8
\&   # \-\-plugin hook
\&   if ( $plugin && $plugin\->can(\*(Aqinit\*(Aq) ) {
\&      $plugin\->init(
\&         slaves         => $slaves,
\&         slave_lag_cxns => $slave_lag_cxns,
\&         repl_table     => $repl_table,
\&      );
\&   }
.Ve
.PP
The comment \f(CW\*(C`# \-\-plugin hook\*(C'\fR precedes every hook call.
.PP
Please contact Percona if you have questions or need help.
.SH "DSN OPTIONS"
.IX Header "DSN OPTIONS"
These \s-1DSN\s0 options are used to create a \s-1DSN.\s0  Each option is given like
\&\f(CW\*(C`option=value\*(C'\fR.  The options are case-sensitive, so P and p are not the
same option.  There cannot be whitespace before or after the \f(CW\*(C`=\*(C'\fR and
if the value contains whitespace it must be quoted.  \s-1DSN\s0 options are
comma-separated.  See the percona-toolkit manpage for full details.
.IP "\(bu" 4
A
.Sp
dsn: charset; copy: yes
.Sp
Default character set.
.IP "\(bu" 4
D
.Sp
copy: no
.Sp
\&\s-1DSN\s0 table database.
.IP "\(bu" 4
F
.Sp
dsn: mysql_read_default_file; copy: yes
.Sp
Defaults file for connection values.
.IP "\(bu" 4
h
.Sp
dsn: host; copy: yes
.Sp
Connect to host.
.IP "\(bu" 4
p
.Sp
dsn: password; copy: yes
.Sp
Password to use when connecting.
If password contains commas they must be escaped with a backslash: \*(L"exam\e,ple\*(R"
.IP "\(bu" 4
P
.Sp
dsn: port; copy: yes
.Sp
Port number to use for connection.
.IP "\(bu" 4
S
.Sp
dsn: mysql_socket; copy: no
.Sp
Socket file to use for connection.
.IP "\(bu" 4
t
.Sp
copy: no
.Sp
\&\s-1DSN\s0 table table.
.IP "\(bu" 4
u
.Sp
dsn: user; copy: yes
.Sp
User for login if not current user.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
The environment variable \f(CW\*(C`PTDEBUG\*(C'\fR enables verbose debugging output to \s-1STDERR.\s0
To enable debugging and capture all output to a file, run the tool like:
.PP
.Vb 1
\&   PTDEBUG=1 pt\-table\-checksum ... > FILE 2>&1
.Ve
.PP
Be careful: debugging output is voluminous and can generate several megabytes
of output.
.SH "SYSTEM REQUIREMENTS"
.IX Header "SYSTEM REQUIREMENTS"
You need Perl, \s-1DBI,\s0 DBD::mysql, and some core packages that ought to be
installed in any reasonably new version of Perl.
.SH "BUGS"
.IX Header "BUGS"
For a list of known bugs, see <http://www.percona.com/bugs/pt\-table\-checksum>.
.PP
Please report bugs at <https://bugs.launchpad.net/percona\-toolkit>.
Include the following information in your bug report:
.IP "\(bu" 4
Complete command-line used to run the tool
.IP "\(bu" 4
Tool \*(L"\-\-version\*(R"
.IP "\(bu" 4
MySQL version of all servers involved
.IP "\(bu" 4
Output from the tool including \s-1STDERR\s0
.IP "\(bu" 4
Input files (log/dump/config files, etc.)
.PP
If possible, include debugging output by running the tool with \f(CW\*(C`PTDEBUG\*(C'\fR;
see \*(L"\s-1ENVIRONMENT\*(R"\s0.
.SH "DOWNLOADING"
.IX Header "DOWNLOADING"
Visit <http://www.percona.com/software/percona\-toolkit/> to download the
latest release of Percona Toolkit.  Or, get the latest release from the
command line:
.PP
.Vb 1
\&   wget percona.com/get/percona\-toolkit.tar.gz
\&
\&   wget percona.com/get/percona\-toolkit.rpm
\&
\&   wget percona.com/get/percona\-toolkit.deb
.Ve
.PP
You can also get individual tools from the latest release:
.PP
.Vb 1
\&   wget percona.com/get/TOOL
.Ve
.PP
Replace \f(CW\*(C`TOOL\*(C'\fR with the name of any tool.
.SH "AUTHORS"
.IX Header "AUTHORS"
Baron Schwartz and Daniel Nichter
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
Claus Jeppesen, Francois Saint-Jacques, Giuseppe Maxia, Heikki Tuuri,
James Briggs, Martin Friebe, and Sergey Zhuravlev
.SH "ABOUT PERCONA TOOLKIT"
.IX Header "ABOUT PERCONA TOOLKIT"
This tool is part of Percona Toolkit, a collection of advanced command-line
tools for MySQL developed by Percona.  Percona Toolkit was forked from two
projects in June, 2011: Maatkit and Aspersa.  Those projects were created by
Baron Schwartz and primarily developed by him and Daniel Nichter.  Visit
<http://www.percona.com/software/> to learn about other free, open-source
software from Percona.
.SH "COPYRIGHT, LICENSE, AND WARRANTY"
.IX Header "COPYRIGHT, LICENSE, AND WARRANTY"
This program is copyright 2011\-2016 Percona \s-1LLC\s0 and/or its affiliates,
2007\-2011 Baron Schwartz.
.PP
\&\s-1THIS PROGRAM IS PROVIDED \*(L"AS IS\*(R" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\s0
.PP
This program is free software; you can redistribute it and/or modify it under
the terms of the \s-1GNU\s0 General Public License as published by the Free Software
Foundation, version 2; \s-1OR\s0 the Perl Artistic License.  On \s-1UNIX\s0 and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.
.PP
You should have received a copy of the \s-1GNU\s0 General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, \s-1MA\s0  02111\-1307  \s-1USA.\s0
.SH "VERSION"
.IX Header "VERSION"
pt-table-checksum 2.2.17
