.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "PT-KILL 1p"
.TH PT-KILL 1p "2016-03-07" "perl v5.34.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
pt\-kill \- Kill MySQL queries that match certain criteria.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Usage: pt-kill [\s-1OPTIONS\s0] [\s-1DSN\s0]
.PP
pt-kill kills MySQL connections.  pt-kill connects to MySQL and gets queries
from \s-1SHOW PROCESSLIST\s0 if no \s-1FILE\s0 is given.  Else, it reads queries from one
or more \s-1FILE\s0 which contains the output of \s-1SHOW PROCESSLIST.\s0  If \s-1FILE\s0 is \-,
pt-kill reads from \s-1STDIN.\s0
.PP
Kill queries running longer than 60s:
.PP
.Vb 1
\&  pt\-kill \-\-busy\-time 60 \-\-kill
.Ve
.PP
Print, do not kill, queries running longer than 60s:
.PP
.Vb 1
\&  pt\-kill \-\-busy\-time 60 \-\-print
.Ve
.PP
Check for sleeping processes and kill them all every 10s:
.PP
.Vb 1
\&  pt\-kill \-\-match\-command Sleep \-\-kill \-\-victims all \-\-interval 10
.Ve
.PP
Print all login processes:
.PP
.Vb 1
\&  pt\-kill \-\-match\-state login \-\-print \-\-victims all
.Ve
.PP
See which queries in the processlist right now would match:
.PP
.Vb 2
\&   mysql \-e "SHOW PROCESSLIST" > proclist.txt
\&   pt\-kill \-\-test\-matching proclist.txt \-\-busy\-time 60 \-\-print
.Ve
.SH "RISKS"
.IX Header "RISKS"
Percona Toolkit is mature, proven in the real world, and well tested,
but all database tools can pose a risk to the system and the database
server.  Before using this tool, please:
.IP "\(bu" 4
Read the tool's documentation
.IP "\(bu" 4
Review the tool's known \*(L"\s-1BUGS\*(R"\s0
.IP "\(bu" 4
Test the tool on a non-production server
.IP "\(bu" 4
Backup your production server and verify the backups
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
pt-kill captures queries from \s-1SHOW PROCESSLIST,\s0 filters them, and then either
kills or prints them.  This is also known as a \*(L"slow query sniper\*(R" in some
circles.  The idea is to watch for queries that might be consuming too many
resources, and kill them.
.PP
For brevity, we talk about killing queries, but they may just be printed
(or some other future action) depending on what options are given.
.PP
Normally pt-kill connects to MySQL to get queries from \s-1SHOW PROCESSLIST.\s0
Alternatively, it can read \s-1SHOW PROCESSLIST\s0 output from files.  In this case,
pt-kill does not connect to MySQL and \*(L"\-\-kill\*(R" has no effect.  You should
use \*(L"\-\-print\*(R" instead when reading files.  The ability to read a file
with \*(L"\-\-test\-matching\*(R" allows you to capture \s-1SHOW PROCESSLIST\s0 and test it
later with pt-kill to make sure that your matches kill the proper queries.
There are a lot of special rules to follow, such as \*(L"don't kill replication
threads,\*(R" so be careful not to kill something important!
.PP
Two important options to know are \*(L"\-\-busy\-time\*(R" and \*(L"\-\-victims\*(R".
First, whereas most match/filter options match their corresponding value from
\&\s-1SHOW PROCESSLIST\s0 (e.g. \*(L"\-\-match\-command\*(R" matches a query's Command value),
the Time value is matched by \*(L"\-\-busy\-time\*(R".  See also \*(L"\-\-interval\*(R".
.PP
Second, \*(L"\-\-victims\*(R" controls which matching queries from each class are
killed.  By default, the matching query with the highest Time value is killed
(the oldest query).  See the next section, \*(L"\s-1GROUP, MATCH AND KILL\*(R"\s0,
for more details.
.PP
Usually you need to specify at least one \f(CW\*(C`\-\-match\*(C'\fR option, else no
queries will match.  Or, you can specify \*(L"\-\-match\-all\*(R" to match all queries
that aren't ignored by an \f(CW\*(C`\-\-ignore\*(C'\fR option.
.SH "GROUP, MATCH AND KILL"
.IX Header "GROUP, MATCH AND KILL"
Queries pass through several steps to determine which exactly will be killed
(or printed\*(--whatever action is specified).  Understanding these steps will
help you match precisely the queries you want.
.PP
The first step is grouping queries into classes.  The \*(L"\-\-group\-by\*(R" option
controls grouping.  By default, this option has no value so all queries are
grouped into one default class.  All types of matching and filtering
(the next step) are applied per-class.  Therefore, you may need to group
queries in order to match/filter some classes but not others.
.PP
The second step is matching.  Matching implies filtering since if a query
doesn't match some criteria, it is removed from its class.
Matching happens for each class.  First, queries are filtered from their
class by the various \f(CW\*(C`Query Matches\*(C'\fR options like \*(L"\-\-match\-user\*(R".
Then, entire classes are filtered by the various \f(CW\*(C`Class Matches\*(C'\fR options
like \*(L"\-\-query\-count\*(R".
.PP
The third step is victim selection, that is, which matching queries in each
class to kill.  This is controlled by the \*(L"\-\-victims\*(R" option.  Although
many queries in a class may match, you may only want to kill the oldest
query, or all queries, etc.
.PP
The forth and final step is to take some action on all matching queries
from all classes.  The \f(CW\*(C`Actions\*(C'\fR options specify which actions will be
taken.  At this step, there are no more classes, just a single list of
queries to kill, print, etc.
.SH "OUTPUT"
.IX Header "OUTPUT"
If only \*(L"\-\-kill\*(R" is given, then there is no output.  If only
\&\*(L"\-\-print\*(R" is given, then a timestamped \s-1KILL\s0 statement if printed
for every query that would have been killed, like:
.PP
.Vb 1
\&  # 2009\-07\-15T15:04:01 KILL 8 (Query 42 sec) SELECT * FROM huge_table
.Ve
.PP
The line shows a timestamp, the query's Id (8), its Time (42 sec) and its
Info (usually the query \s-1SQL\s0).
.PP
If both \*(L"\-\-kill\*(R" and \*(L"\-\-print\*(R" are given, then matching queries are
killed and a line for each like the one above is printed.
.PP
Any command executed by \*(L"\-\-execute\-command\*(R" is responsible for its own
output and logging.  After being executed, pt-kill has no control or interaction
with the command.
.SH "OPTIONS"
.IX Header "OPTIONS"
Specify at least one of \*(L"\-\-kill\*(R", \*(L"\-\-kill\-query\*(R", \*(L"\-\-print\*(R", \*(L"\-\-execute\-command\*(R" or \*(L"\-\-stop\*(R".
.PP
\&\*(L"\-\-any\-busy\-time\*(R" and \*(L"\-\-each\-busy\-time\*(R" are mutually exclusive.
.PP
\&\*(L"\-\-kill\*(R" and \*(L"\-\-kill\-query\*(R" are mutually exclusive.
.PP
\&\*(L"\-\-daemonize\*(R" and \*(L"\-\-test\-matching\*(R" are mutually exclusive.
.PP
This tool accepts additional command-line arguments.  Refer to the
\&\*(L"\s-1SYNOPSIS\*(R"\s0 and usage information for details.
.IP "\-\-ask\-pass" 4
.IX Item "--ask-pass"
Prompt for a password when connecting to MySQL.
.IP "\-\-charset" 4
.IX Item "--charset"
short form: \-A; type: string
.Sp
Default character set.  If the value is utf8, sets Perl's binmode on
\&\s-1STDOUT\s0 to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and runs \s-1SET
NAMES UTF8\s0 after connecting to MySQL.  Any other value sets binmode on \s-1STDOUT\s0
without the utf8 layer, and runs \s-1SET NAMES\s0 after connecting to MySQL.
.IP "\-\-config" 4
.IX Item "--config"
type: Array
.Sp
Read this comma-separated list of config files; if specified, this must be the
first option on the command line.
.IP "\-\-create\-log\-table" 4
.IX Item "--create-log-table"
Create the \*(L"\-\-log\-dsn\*(R" table if it does not exist.
.Sp
This option causes the table specified by \*(L"\-\-log\-dsn\*(R" to be created with the
default structure shown in the documentation for that option.
.IP "\-\-daemonize" 4
.IX Item "--daemonize"
Fork to the background and detach from the shell.  \s-1POSIX\s0 operating systems
only.
.IP "\-\-database" 4
.IX Item "--database"
short form: \-D; type: string
.Sp
The database to use for the connection.
.IP "\-\-defaults\-file" 4
.IX Item "--defaults-file"
short form: \-F; type: string
.Sp
Only read mysql options from the given file.  You must give an absolute
pathname.
.IP "\-\-filter" 4
.IX Item "--filter"
type: string
.Sp
Discard events for which this Perl code doesn't return true.
.Sp
This option is a string of Perl code or a file containing Perl code that gets
compiled into a subroutine with one argument: \f(CW$event\fR.  This is a hashref.
If the given value is a readable file, then pt-kill reads the entire
file and uses its contents as the code.  The file should not contain
a shebang (#!/usr/bin/perl) line.
.Sp
If the code returns true, the chain of callbacks continues; otherwise it ends.
The code is the last statement in the subroutine other than \f(CW\*(C`return $event\*(C'\fR. 
The subroutine template is:
.Sp
.Vb 1
\&  sub { $event = shift; filter && return $event; }
.Ve
.Sp
Filters given on the command line are wrapped inside parentheses like like
\&\f(CW\*(C`( filter )\*(C'\fR.  For complex, multi-line filters, you must put the code inside
a file so it will not be wrapped inside parentheses.  Either way, the filter
must produce syntactically valid code given the template.  For example, an
if-else branch given on the command line would not be valid:
.Sp
.Vb 1
\&  \-\-filter \*(Aqif () { } else { }\*(Aq  # WRONG
.Ve
.Sp
Since it's given on the command line, the if-else branch would be wrapped inside
parentheses which is not syntactically valid.  So to accomplish something more
complex like this would require putting the code in a file, for example
filter.txt:
.Sp
.Vb 1
\&  my $event_ok; if (...) { $event_ok=1; } else { $event_ok=0; } $event_ok
.Ve
.Sp
Then specify \f(CW\*(C`\-\-filter filter.txt\*(C'\fR to read the code from filter.txt.
.Sp
If the filter code won't compile, pt-kill will die with an error.
If the filter code does compile, an error may still occur at runtime if the
code tries to do something wrong (like pattern match an undefined value).
pt-kill does not provide any safeguards so code carefully!
.Sp
It is permissible for the code to have side effects (to alter \f(CW$event\fR).
.IP "\-\-group\-by" 4
.IX Item "--group-by"
type: string
.Sp
Apply matches to each class of queries grouped by this \s-1SHOW PROCESSLIST\s0 column.
In addition to the basic columns of \s-1SHOW PROCESSLIST\s0 (user, host, command,
state, etc.), queries can be matched by \f(CW\*(C`fingerprint\*(C'\fR which abstracts the
\&\s-1SQL\s0 query in the \f(CW\*(C`Info\*(C'\fR column.
.Sp
By default, queries are not grouped, so matches and actions apply to all
queries.  Grouping allows matches and actions to apply to classes of
similar queries, if any queries in the class match.
.Sp
For example, detecting cache stampedes (see \f(CW\*(C`all\-but\-oldest\*(C'\fR under
\&\*(L"\-\-victims\*(R" for an explanation of that term) requires that queries are
grouped by the \f(CW\*(C`arg\*(C'\fR attribute.  This creates classes of identical queries
(stripped of comments).  So queries \f(CW"SELECT c FROM t WHERE id=1"\fR and
\&\f(CW"SELECT c FROM t WHERE id=1"\fR are grouped into the same class, but
query c<\*(L"\s-1SELECT\s0 c \s-1FROM\s0 t \s-1WHERE\s0 id=3\*(R"> is not identical to the first two
queries so it is grouped into another class. Then when \*(L"\-\-victims\*(R"
\&\f(CW\*(C`all\-but\-oldest\*(C'\fR is specified, all but the oldest query in each class is
killed for each class of queries that matches the match criteria.
.IP "\-\-help" 4
.IX Item "--help"
Show help and exit.
.IP "\-\-host" 4
.IX Item "--host"
short form: \-h; type: string; default: localhost
.Sp
Connect to host.
.IP "\-\-interval" 4
.IX Item "--interval"
type: time
.Sp
How often to check for queries to kill.  If \*(L"\-\-busy\-time\*(R" is not given,
then the default interval is 30 seconds.  Else the default is half as often
as \*(L"\-\-busy\-time\*(R".  If both \*(L"\-\-interval\*(R" and \*(L"\-\-busy\-time\*(R" are given,
then the explicit \*(L"\-\-interval\*(R" value is used.
.Sp
See also \*(L"\-\-run\-time\*(R".
.IP "\-\-log" 4
.IX Item "--log"
type: string
.Sp
Print all output to this file when daemonized.
.IP "\-\-log\-dsn" 4
.IX Item "--log-dsn"
type: \s-1DSN\s0
.Sp
Store each query killed in this \s-1DSN.\s0
.Sp
The argument specifies a table to store all killed queries.  The \s-1DSN\s0
passed in must have the databse (D) and table (t) options. The
table must have at least the following columns.  You can add more columns for
your own special purposes, but they won't be used by pt-kill.  The
following \s-1CREATE TABLE\s0 definition is also used for \*(L"\-\-create\-log\-table\*(R".
MAGIC_create_log_table:
.Sp
.Vb 10
\&   CREATE TABLE kill_log (
\&      kill_id     int(10) unsigned NOT NULL AUTO_INCREMENT,
\&      server_id   bigint(4) NOT NULL DEFAULT \*(Aq0\*(Aq,
\&      timestamp   DATETIME,
\&      reason      TEXT,
\&      kill_error  TEXT,
\&      Id          bigint(4) NOT NULL DEFAULT \*(Aq0\*(Aq,
\&      User        varchar(16) NOT NULL DEFAULT \*(Aq\*(Aq,
\&      Host        varchar(64) NOT NULL DEFAULT \*(Aq\*(Aq,
\&      db          varchar(64) DEFAULT NULL,
\&      Command     varchar(16) NOT NULL DEFAULT \*(Aq\*(Aq,
\&      Time        int(7) NOT NULL DEFAULT \*(Aq0\*(Aq,
\&      State       varchar(64) DEFAULT NULL,
\&      Info        longtext,
\&      Time_ms     bigint(21) DEFAULT \*(Aq0\*(Aq, # NOTE, TODO: currently not used
\&      PRIMARY KEY (kill_id)
\&   ) DEFAULT CHARSET=utf8
.Ve
.IP "\-\-password" 4
.IX Item "--password"
short form: \-p; type: string
.Sp
Password to use when connecting.
If password contains commas they must be escaped with a backslash: \*(L"exam\e,ple\*(R"
.IP "\-\-pid" 4
.IX Item "--pid"
type: string
.Sp
Create the given \s-1PID\s0 file.  The tool won't start if the \s-1PID\s0 file already
exists and the \s-1PID\s0 it contains is different than the current \s-1PID.\s0  However,
if the \s-1PID\s0 file exists and the \s-1PID\s0 it contains is no longer running, the
tool will overwrite the \s-1PID\s0 file with the current \s-1PID.\s0  The \s-1PID\s0 file is
removed automatically when the tool exits.
.IP "\-\-port" 4
.IX Item "--port"
short form: \-P; type: int
.Sp
Port number to use for connection.
.IP "\-\-query\-id" 4
.IX Item "--query-id"
Prints an \s-1ID\s0 of the query that was just killed. This is 
equivalent to the \*(L"\s-1ID\*(R"\s0 output of pt-query-digest. This allows 
cross-referencing the output of both tools.
.Sp
Example:
.Sp
.Vb 1
\&   Query ID 0xE9800998ECF8427E
.Ve
.Sp
Note that this is a digest (or hash) of the query's \*(L"fingerprint\*(R", 
so queries of the same form but with different values will have the same \s-1ID.\s0
See pt-query-digest for more information.
.IP "\-\-rds" 4
.IX Item "--rds"
Denotes the instance in question is on Amazon \s-1RDS.\s0 By default pt-kill runs
the MySQL command \*(L"kill\*(R" for \*(L"\-\-kill\*(R" and \*(L"kill query\*(R" \*(L"\-\-kill\-query\*(R".
On \s-1RDS\s0 these two commands are not available and are replaced by function calls.
This option modifies \*(L"\-\-kill\*(R" to use \*(L"\s-1CALL\s0 mysql.rds_kill(thread\-id)\*(R" instead
and \*(L"\-\-kill\-query\*(R" to use \*(L"\s-1CALL\s0 mysql.rds_kill_query(thread\-id)\*(R"
.IP "\-\-run\-time" 4
.IX Item "--run-time"
type: time
.Sp
How long to run before exiting.  By default pt-kill runs forever, or until
its process is killed or stopped by the creation of a \*(L"\-\-sentinel\*(R" file.
If this option is specified, pt-kill runs for the specified amount of time
and sleeps \*(L"\-\-interval\*(R" seconds between each check of the \s-1PROCESSLIST.\s0
.IP "\-\-sentinel" 4
.IX Item "--sentinel"
type: string; default: /tmp/pt\-kill\-sentinel
.Sp
Exit if this file exists.
.Sp
The presence of the file specified by \*(L"\-\-sentinel\*(R" will cause all
running instances of pt-kill to exit.  You might find this handy to stop cron
jobs gracefully if necessary.  See also \*(L"\-\-stop\*(R".
.IP "\-\-set\-vars" 4
.IX Item "--set-vars"
type: Array
.Sp
Set the MySQL variables in this comma-separated list of \f(CW\*(C`variable=value\*(C'\fR pairs.
.Sp
By default, the tool sets:
.Sp
.Vb 1
\&   wait_timeout=10000
.Ve
.Sp
Variables specified on the command line override these defaults.  For
example, specifying \f(CW\*(C`\-\-set\-vars wait_timeout=500\*(C'\fR overrides the defaultvalue of \f(CW10000\fR.
.Sp
The tool prints a warning and continues if a variable cannot be set.
.IP "\-\-socket" 4
.IX Item "--socket"
short form: \-S; type: string
.Sp
Socket file to use for connection.
.IP "\-\-stop" 4
.IX Item "--stop"
Stop running instances by creating the \*(L"\-\-sentinel\*(R" file.
.Sp
Causes pt-kill to create the sentinel file specified by \*(L"\-\-sentinel\*(R" and
exit.  This should have the effect of stopping all running instances which are
watching the same sentinel file.
.IP "\-\-[no]strip\-comments" 4
.IX Item "--[no]strip-comments"
default: yes
.Sp
Remove \s-1SQL\s0 comments from queries in the Info column of the \s-1PROCESSLIST.\s0
.IP "\-\-user" 4
.IX Item "--user"
short form: \-u; type: string
.Sp
User for login if not current user.
.IP "\-\-version" 4
.IX Item "--version"
Show version and exit.
.IP "\-\-[no]version\-check" 4
.IX Item "--[no]version-check"
default: yes
.Sp
Check for the latest version of Percona Toolkit, MySQL, and other programs.
.Sp
This is a standard \*(L"check for updates automatically\*(R" feature, with two
additional features.  First, the tool checks the version of other programs
on the local system in addition to its own version.  For example, it checks
the version of every MySQL server it connects to, Perl, and the Perl module
DBD::mysql.  Second, it checks for and warns about versions with known
problems.  For example, MySQL 5.5.25 had a critical bug and was re-released
as 5.5.25a.
.Sp
Any updates or known problems are printed to \s-1STDOUT\s0 before the tool's normal
output.  This feature should never interfere with the normal operation of the
tool.
.Sp
For more information, visit <https://www.percona.com/version\-check>.
.IP "\-\-victims" 4
.IX Item "--victims"
type: string; default: oldest
.Sp
Which of the matching queries in each class will be killed.  After classes
have been matched/filtered, this option specifies which of the matching
queries in each class will be killed (or printed, etc.).  The following
values are possible:
.RS 4
.IP "oldest" 4
.IX Item "oldest"
Only kill the single oldest query.  This is to prevent killing queries that
aren't really long-running, they're just long-waiting.  This sorts matching
queries by Time and kills the one with the highest Time value.
.IP "all" 4
.IX Item "all"
Kill all queries in the class.
.IP "all-but-oldest" 4
.IX Item "all-but-oldest"
Kill all but the oldest query.  This is the inverse of the \f(CW\*(C`oldest\*(C'\fR value.
.Sp
This value can be used to prevent \*(L"cache stampedes\*(R", the condition where
several identical queries are executed and create a backlog while the first
query attempts to finish.  Since all queries are identical, all but the first
query are killed so that it can complete and populate the cache.
.RE
.RS 4
.RE
.IP "\-\-wait\-after\-kill" 4
.IX Item "--wait-after-kill"
type: time
.Sp
Wait after killing a query, before looking for more to kill.  The purpose of
this is to give blocked queries a chance to execute, so we don't kill a query
that's blocking a bunch of others, and then kill the others immediately
afterwards.
.IP "\-\-wait\-before\-kill" 4
.IX Item "--wait-before-kill"
type: time
.Sp
Wait before killing a query.  The purpose of this is to give
\&\*(L"\-\-execute\-command\*(R" a chance to see the matching query and gather other
MySQL or system information before it's killed.
.SS "\s-1QUERY MATCHES\s0"
.IX Subsection "QUERY MATCHES"
These options filter queries from their classes.  If a query does not
match, it is removed from its class.  The \f(CW\*(C`\-\-ignore\*(C'\fR options take precedence.
The matches for command, db, host, etc. correspond to the columns returned
by \s-1SHOW PROCESSLIST:\s0 Command, db, Host, etc.  All pattern matches are
case-sensitive by default, but they can be made case-insensitive by specifying
a regex pattern like \f(CW\*(C`(?i\-xsm:select)\*(C'\fR.
.PP
See also \*(L"\s-1GROUP, MATCH AND KILL\*(R"\s0.
.IP "\-\-busy\-time" 4
.IX Item "--busy-time"
type: time; group: Query Matches
.Sp
Match queries that have been running for longer than this time.  The queries
must be in Command=Query status.  This matches a query's Time value as
reported by \s-1SHOW PROCESSLIST.\s0
.IP "\-\-idle\-time" 4
.IX Item "--idle-time"
type: time; group: Query Matches
.Sp
Match queries that have been idle/sleeping for longer than this time.
The queries must be in Command=Sleep status.  This matches a query's Time
value as reported by \s-1SHOW PROCESSLIST.\s0
.IP "\-\-ignore\-command" 4
.IX Item "--ignore-command"
type: string; group: Query Matches
.Sp
Ignore queries whose Command matches this Perl regex.
.Sp
See \*(L"\-\-match\-command\*(R".
.IP "\-\-ignore\-db" 4
.IX Item "--ignore-db"
type: string; group: Query Matches
.Sp
Ignore queries whose db (database) matches this Perl regex.
.Sp
See \*(L"\-\-match\-db\*(R".
.IP "\-\-ignore\-host" 4
.IX Item "--ignore-host"
type: string; group: Query Matches
.Sp
Ignore queries whose Host matches this Perl regex.
.Sp
See \*(L"\-\-match\-host\*(R".
.IP "\-\-ignore\-info" 4
.IX Item "--ignore-info"
type: string; group: Query Matches
.Sp
Ignore queries whose Info (query) matches this Perl regex.
.Sp
See \*(L"\-\-match\-info\*(R".
.IP "\-\-[no]ignore\-self" 4
.IX Item "--[no]ignore-self"
default: yes; group: Query Matches
.Sp
Don't kill pt-kill's own connection.
.IP "\-\-ignore\-state" 4
.IX Item "--ignore-state"
type: string; group: Query Matches; default: Locked
.Sp
Ignore queries whose State matches this Perl regex.  The default is to keep
threads from being killed if they are locked waiting for another thread.
.Sp
See \*(L"\-\-match\-state\*(R".
.IP "\-\-ignore\-user" 4
.IX Item "--ignore-user"
type: string; group: Query Matches
.Sp
Ignore queries whose user matches this Perl regex.
.Sp
See \*(L"\-\-match\-user\*(R".
.IP "\-\-match\-all" 4
.IX Item "--match-all"
group: Query Matches
.Sp
Match all queries that are not ignored.  If no ignore options are specified,
then every query matches (except replication threads, unless
\&\*(L"\-\-replication\-threads\*(R" is also specified).  This option allows you to
specify negative matches, i.e. "match every query \fIexcept\fR..." where the
exceptions are defined by specifying various \f(CW\*(C`\-\-ignore\*(C'\fR options.
.Sp
This option is \fInot\fR the same as \*(L"\-\-victims\*(R" \f(CW\*(C`all\*(C'\fR.  This option matches
all queries within a class, whereas \*(L"\-\-victims\*(R" \f(CW\*(C`all\*(C'\fR specifies that all
matching queries in a class (however they matched) will be killed.  Normally,
however, the two are used together because if, for example, you specify
\&\*(L"\-\-victims\*(R" \f(CW\*(C`oldest\*(C'\fR, then although all queries may match, only the oldest
will be killed.
.IP "\-\-match\-command" 4
.IX Item "--match-command"
type: string; group: Query Matches
.Sp
Match only queries whose Command matches this Perl regex.
.Sp
Common Command values are:
.Sp
.Vb 10
\&  Query
\&  Sleep
\&  Binlog Dump
\&  Connect
\&  Delayed insert
\&  Execute
\&  Fetch
\&  Init DB
\&  Kill
\&  Prepare
\&  Processlist
\&  Quit
\&  Reset stmt
\&  Table Dump
.Ve
.Sp
See <http://dev.mysql.com/doc/refman/5.1/en/thread\-commands.html> for a full
list and description of Command values.
.IP "\-\-match\-db" 4
.IX Item "--match-db"
type: string; group: Query Matches
.Sp
Match only queries whose db (database) matches this Perl regex.
.IP "\-\-match\-host" 4
.IX Item "--match-host"
type: string; group: Query Matches
.Sp
Match only queries whose Host matches this Perl regex.
.Sp
The Host value often time includes the port like \*(L"host:port\*(R".
.IP "\-\-match\-info" 4
.IX Item "--match-info"
type: string; group: Query Matches
.Sp
Match only queries whose Info (query) matches this Perl regex.
.Sp
The Info column of the processlist shows the query that is being executed
or \s-1NULL\s0 if no query is being executed.
.IP "\-\-match\-state" 4
.IX Item "--match-state"
type: string; group: Query Matches
.Sp
Match only queries whose State matches this Perl regex.
.Sp
Common State values are:
.Sp
.Vb 10
\&  Locked
\&  login
\&  copy to tmp table
\&  Copying to tmp table
\&  Copying to tmp table on disk
\&  Creating tmp table
\&  executing
\&  Reading from net
\&  Sending data
\&  Sorting for order
\&  Sorting result
\&  Table lock
\&  Updating
.Ve
.Sp
See <http://dev.mysql.com/doc/refman/5.1/en/general\-thread\-states.html> for
a full list and description of State values.
.IP "\-\-match\-user" 4
.IX Item "--match-user"
type: string; group: Query Matches
.Sp
Match only queries whose User matches this Perl regex.
.IP "\-\-replication\-threads" 4
.IX Item "--replication-threads"
group: Query Matches
.Sp
Allow matching and killing replication threads.
.Sp
By default, matches do not apply to replication threads; i.e. replication
threads are completely ignored.  Specifying this option allows matches to
match (and potentially kill) replication threads on masters and slaves.
.IP "\-\-test\-matching" 4
.IX Item "--test-matching"
type: array; group: Query Matches
.Sp
Files with processlist snapshots to test matching options against.  Since
the matching options can be complex, you can save snapshots of processlist
in files, then test matching options against queries in those files.
.Sp
This option disables \*(L"\-\-run\-time\*(R", \*(L"\-\-interval\*(R",
and \*(L"\-\-[no]ignore\-self\*(R".
.SS "\s-1CLASS MATCHES\s0"
.IX Subsection "CLASS MATCHES"
These matches apply to entire query classes.  Classes are created by specifying
the \*(L"\-\-group\-by\*(R" option, else all queries are members of a single, default
class.
.PP
See also \*(L"\s-1GROUP, MATCH AND KILL\*(R"\s0.
.IP "\-\-any\-busy\-time" 4
.IX Item "--any-busy-time"
type: time; group: Class Matches
.Sp
Match query class if any query has been running for longer than this time.
\&\*(L"Longer than\*(R" means that if you specify \f(CW10\fR, for example, the class will
only match if there's at least one query that has been running for greater
than 10 seconds.
.Sp
See \*(L"\-\-each\-busy\-time\*(R" for more details.
.IP "\-\-each\-busy\-time" 4
.IX Item "--each-busy-time"
type: time; group: Class Matches
.Sp
Match query class if each query has been running for longer than this time.
\&\*(L"Longer than\*(R" means that if you specify \f(CW10\fR, for example, the class will
only match if each and every query has been running for greater than 10
seconds.
.Sp
See also \*(L"\-\-any\-busy\-time\*(R" (to match a class if \s-1ANY\s0 query has been running
longer than the specified time) and \*(L"\-\-busy\-time\*(R".
.IP "\-\-query\-count" 4
.IX Item "--query-count"
type: int; group: Class Matches
.Sp
Match query class if it has at least this many queries.  When queries are
grouped into classes by specifying \*(L"\-\-group\-by\*(R", this option causes matches
to apply only to classes with at least this many queries.  If \*(L"\-\-group\-by\*(R"
is not specified then this option causes matches to apply only if there
are at least this many queries in the entire \s-1SHOW PROCESSLIST.\s0
.IP "\-\-verbose" 4
.IX Item "--verbose"
short form: \-v
.Sp
Print information to \s-1STDOUT\s0 about what is being done.
.SS "\s-1ACTIONS\s0"
.IX Subsection "ACTIONS"
These actions are taken for every matching query from all classes.
The actions are taken in this order: \*(L"\-\-print\*(R", \*(L"\-\-execute\-command\*(R",
\&\*(L"\-\-kill\*(R"/\*(L"\-\-kill\-query\*(R".  This order allows \*(L"\-\-execute\-command\*(R"
to see the output of \*(L"\-\-print\*(R" and the query before
\&\*(L"\-\-kill\*(R"/\*(L"\-\-kill\-query\*(R".  This may be helpful because pt-kill does
not pass any information to \*(L"\-\-execute\-command\*(R".
.PP
See also \*(L"\s-1GROUP, MATCH AND KILL\*(R"\s0.
.IP "\-\-execute\-command" 4
.IX Item "--execute-command"
type: string; group: Actions
.Sp
Execute this command when a query matches.
.Sp
After the command is executed, pt-kill has no control over it, so the command
is responsible for its own info gathering, logging, interval, etc.  The
command is executed each time a query matches, so be careful that the command
behaves well when multiple instances are ran.  No information from pt-kill is
passed to the command.
.Sp
See also \*(L"\-\-wait\-before\-kill\*(R".
.IP "\-\-kill" 4
.IX Item "--kill"
group: Actions
.Sp
Kill the connection for matching queries.
.Sp
This option makes pt-kill kill the connections (a.k.a. processes, threads) that
have matching queries.  Use \*(L"\-\-kill\-query\*(R" if you only want to kill
individual queries and not their connections.
.Sp
Unless \*(L"\-\-print\*(R" is also given, no other information is printed that shows
that pt-kill matched and killed a query.
.Sp
See also \*(L"\-\-wait\-before\-kill\*(R" and \*(L"\-\-wait\-after\-kill\*(R".
.IP "\-\-kill\-query" 4
.IX Item "--kill-query"
group: Actions
.Sp
Kill matching queries.
.Sp
This option makes pt-kill kill matching queries.  This requires MySQL 5.0 or
newer.  Unlike \*(L"\-\-kill\*(R" which kills the connection for matching queries,
this option only kills the query, not its connection.
.IP "\-\-print" 4
.IX Item "--print"
group: Actions
.Sp
Print a \s-1KILL\s0 statement for matching queries; does not actually kill queries.
.Sp
If you just want to see which queries match and would be killed without
actually killing them, specify \*(L"\-\-print\*(R".  To both kill and print
matching queries, specify both \*(L"\-\-kill\*(R" and \*(L"\-\-print\*(R".
.SH "DSN OPTIONS"
.IX Header "DSN OPTIONS"
These \s-1DSN\s0 options are used to create a \s-1DSN.\s0  Each option is given like
\&\f(CW\*(C`option=value\*(C'\fR.  The options are case-sensitive, so P and p are not the
same option.  There cannot be whitespace before or after the \f(CW\*(C`=\*(C'\fR and
if the value contains whitespace it must be quoted.  \s-1DSN\s0 options are
comma-separated.  See the percona-toolkit manpage for full details.
.IP "\(bu" 4
A
.Sp
dsn: charset; copy: yes
.Sp
Default character set.
.IP "\(bu" 4
D
.Sp
dsn: database; copy: yes
.Sp
Default database.
.IP "\(bu" 4
F
.Sp
dsn: mysql_read_default_file; copy: yes
.Sp
Only read default options from the given file
.IP "\(bu" 4
h
.Sp
dsn: host; copy: yes
.Sp
Connect to host.
.IP "\(bu" 4
p
.Sp
dsn: password; copy: yes
.Sp
Password to use when connecting.
If password contains commas they must be escaped with a backslash: \*(L"exam\e,ple\*(R"
.IP "\(bu" 4
P
.Sp
dsn: port; copy: yes
.Sp
Port number to use for connection.
.IP "\(bu" 4
S
.Sp
dsn: mysql_socket; copy: yes
.Sp
Socket file to use for connection.
.IP "\(bu" 4
u
.Sp
dsn: user; copy: yes
.Sp
User for login if not current user.
.IP "\(bu" 4
t
.Sp
Table to log actions in, if passed through \-\-log\-dsn.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
The environment variable \f(CW\*(C`PTDEBUG\*(C'\fR enables verbose debugging output to \s-1STDERR.\s0
To enable debugging and capture all output to a file, run the tool like:
.PP
.Vb 1
\&   PTDEBUG=1 pt\-kill ... > FILE 2>&1
.Ve
.PP
Be careful: debugging output is voluminous and can generate several megabytes
of output.
.SH "SYSTEM REQUIREMENTS"
.IX Header "SYSTEM REQUIREMENTS"
You need Perl, \s-1DBI,\s0 DBD::mysql, and some core packages that ought to be
installed in any reasonably new version of Perl.
.SH "BUGS"
.IX Header "BUGS"
For a list of known bugs, see <http://www.percona.com/bugs/pt\-kill>.
.PP
Please report bugs at <https://bugs.launchpad.net/percona\-toolkit>.
Include the following information in your bug report:
.IP "\(bu" 4
Complete command-line used to run the tool
.IP "\(bu" 4
Tool \*(L"\-\-version\*(R"
.IP "\(bu" 4
MySQL version of all servers involved
.IP "\(bu" 4
Output from the tool including \s-1STDERR\s0
.IP "\(bu" 4
Input files (log/dump/config files, etc.)
.PP
If possible, include debugging output by running the tool with \f(CW\*(C`PTDEBUG\*(C'\fR;
see \*(L"\s-1ENVIRONMENT\*(R"\s0.
.SH "DOWNLOADING"
.IX Header "DOWNLOADING"
Visit <http://www.percona.com/software/percona\-toolkit/> to download the
latest release of Percona Toolkit.  Or, get the latest release from the
command line:
.PP
.Vb 1
\&   wget percona.com/get/percona\-toolkit.tar.gz
\&
\&   wget percona.com/get/percona\-toolkit.rpm
\&
\&   wget percona.com/get/percona\-toolkit.deb
.Ve
.PP
You can also get individual tools from the latest release:
.PP
.Vb 1
\&   wget percona.com/get/TOOL
.Ve
.PP
Replace \f(CW\*(C`TOOL\*(C'\fR with the name of any tool.
.SH "AUTHORS"
.IX Header "AUTHORS"
Baron Schwartz and Daniel Nichter
.SH "ABOUT PERCONA TOOLKIT"
.IX Header "ABOUT PERCONA TOOLKIT"
This tool is part of Percona Toolkit, a collection of advanced command-line
tools for MySQL developed by Percona.  Percona Toolkit was forked from two
projects in June, 2011: Maatkit and Aspersa.  Those projects were created by
Baron Schwartz and primarily developed by him and Daniel Nichter.  Visit
<http://www.percona.com/software/> to learn about other free, open-source
software from Percona.
.SH "COPYRIGHT, LICENSE, AND WARRANTY"
.IX Header "COPYRIGHT, LICENSE, AND WARRANTY"
This program is copyright 2011\-2016 Percona \s-1LLC\s0 and/or its affiliates,
2009\-2011 Baron Schwartz.
.PP
\&\s-1THIS PROGRAM IS PROVIDED \*(L"AS IS\*(R" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\s0
.PP
This program is free software; you can redistribute it and/or modify it under
the terms of the \s-1GNU\s0 General Public License as published by the Free Software
Foundation, version 2; \s-1OR\s0 the Perl Artistic License.  On \s-1UNIX\s0 and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.
.PP
You should have received a copy of the \s-1GNU\s0 General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, \s-1MA\s0  02111\-1307  \s-1USA.\s0
.SH "VERSION"
.IX Header "VERSION"
pt-kill 2.2.17
